-> CodeRoad: Start <- To start the VM in the command palette 
-> echo hello bash
-> echo hello bash > stdout.txt
	-> This is redirecting the output of a command into a file 
	-> This creates a txt file 
-> echo hello bash >> stdout.txt
	-> >> <- To append to a file 
-> echo hello bash > stdout.txt
	-> To override the file 
-> > stdout.txt
	-> To redirect nothing into the file (to empty it)
-> bad_command > stderr.txt <- Another example 
-> bad_command 2> stderr.txt
	-> stdout (standard out) -> for when a command is successful
	-> stderr -> for when a command isn't successful 
	-> Redirecting the error of a command we know is wrong into a file 
-> echo hello bash 1> stdout.txt
	-> Redirecting the error message to another file meant that it wasn't printed in the terminal 
	-> It redirected to a file 
-> read NAME
	-> stdin (standard in) <- For input 
	-> Keyboard is the default 
	-> read NAME <- To see a command that uses stdin 
-> read NAME 
	-> It's asking for an input <- This is how you ask the user for an input in Bash (read the input which the user enters)
	-> echo $NAME 
	-> It actually creates a variable when you do this 
-> echo $NAME > stdout.txt
	-> When you redirect to a file like this, it's actually overwriting the content of that file 
-> echo freeCodeCamp > name.txt
	-> Redirecting to a file which doesn't exist will create that file and then fill it with whatever you are redirecting to it 
-> read NAME < name.txt 
	-> < <- For input 
	-> > <- For output 
		-> You read from left to right, do it makes sense that this is output (we more commonly see them)
	-> read <- Creates a variable and sets it value equal to whatever the user enters
	-> It's a command which we're running -> then piping what is input into that variable into the name.txt file 
	-> Something is input into a variable -> so we're redirecting that input to another file 
	-> When something is output from a program, function, et al we use >, because it is being output from that program - not for example only taking input from the user 
-> echo firstName | read NAME 
	-> To pipe (|) the output of one command to the input of another 
		-> This creates another subshell / process
		-> Effectively another terminal where this took place (not this one)
	-> The output of the first command is the stdout (standard output)
	-> The input of the other command is the stdin (standard input)
-> echo $NAME <- To test if this worked
	-> Once you have answers from solving problems, you check them to see if they make sense 
-> cat
	-> Concatenate 
	-> Display the contents of the files, or concatenate them together 
-> Control C <- To back out of a process which is running in the terminal 
-> cat name.txt
	-> name.txt is the argument of that command 
	-> It's printing the contents of the file 
-> cat < name.txt
	-> This does the same thing as in the previous line (overall)
	-> Take what is stored in the name.txt file, and use it as the standard input of the cat file 
	-> Which prints its contents into the terminal 
-> echo firstName | cat
	-> Pipe the output of the first command into the second
	-> ('Print the first name in the terminal') <- take the command which does this, and pipe its output as the input of the command which prints outputs into the terminal 
-> touch script.sh
-> chmod +x script.sh
	-> We have made a shell script and given it executable file permissions 
	-> #!/bin/bash <- Then added a shebang line so it uses a Bash interpreter 
-> ./script.sh <- Running the .sh file 
	-> stdin <- Standard input
	-> stdout <- Standard output 
	-> stderr <- Standard error 
	-> script.sh is a file (like the txt file we used cat on earlier was)
	-> You can pipe the output of Bash scripts 
-> echo firstName | ./script.sh
	-> This means, pipe the output of the first command as the input to the second one 
-> echo firstName | ./script.sh 2> stderr.txt
	-> echo firstName | ./script.sh <- Pipe the output of the first command as the input of the second one (use this as the argument of the script.sh file when it's run
	-> 2> stderr.txt <- And pipe the output of this to the stderr.txt file 
-> echo firstName | ./script.sh 2> stderr.txt > stdout.txt
	-> echo firstName | ./script.sh <- Use (pipe) the output of this command as the input to the second one 
	-> 2> stderr.txt > stdout.txt 
		-> This does two redirections <- redirection meaning, take the output of this and store it in this file 
		-> The first is to take the second output of the ./script.sh command and put it into the stderr.txt file 
		-> The second was to take the output of the ./script.sh command and put it into the stdout.txt file 
		-> In this case the first output of the ./script.sh command was an error message and the second was a valid output
		-> This is the contents of that Bash script:
			#!/bin/bash
			read NAME
			echo Hello $NAME
			bad_command
-> ./script.sh < name.txt
	-> If a program has multiple outputs, you can redirect them to several different files 
	-> Use the contents of the name.txt file as the input to the script.sh shell file, and run it
-> ./script.sh < name.txt 2> stderr.txt
	-> Run the same command as before, but take the second output (the error message) and redirect it into another txt file 
-> ./script.sh < name.txt 2> stderr.txt > stdout.txt
 	-> The same as the previous file, but redirect the first output of the program to a different txt file 
-> cat kitty_ipsum_1.txt <- Print the contents of this file into the terminal 
	-> When the argument of the cat function is a single file, print the contents of that file in the terminal 
	-> kitty_ipsum <- This contains placeholder text 
-> wc kitty_ipsum_1.txt
	-> Return file metadata
	-> That file is the argument of the command 
-> man wc <- Manual pages
-> wc -l kitty_ipsum_1.txt
	-> Word count
	-> -l is a flag 
	-> Only the number of lines in the file
-> wc -w kitty_ipsum_1.txt
	-> Count the number of words 
-> wc -m kitty_ipsum_1.txt
	-> How many characters the file has 
	-> -m < This is a flag
-> wc kitty_ipsum_1.txt 
	-> Bite count 
-> cat kitty_ipsum_1.txt | wc
-> wc < kitty_ipsum_1.txt
	-> | might not give you what you want -> instead you might need to use < to redirect the output of one command as the input to the next
-> echo "~~ kitty_ipsum_1.txt info ~~" > kitty_info.txt
	-> Print this string in a new file called kitty_info.txt we are going to populate 
-> echo -e "\nNumber of lines:" >> kitty_info.txt
	-> To append output to a file 
-> cat kitty_ipsum_1.txt | wc -l >> kitty_info.txt
	-> cat kitty_ipsum_1.txt <- Take all of the content of this txt file
	-> | wc -l <- Pipe the contents of that file to the input of this command 
		-> Use the word count command and the flag which counts the number of lines in that file 
	-> Append the output of that to the txt file called kitty_info.txt
-> echo -e "\nNumber of words:" >> kitty_info.txt
	-> This does the same thing as the previous line, but for the word count 
	-> -e <- Read as 'e flag'
-> cat kitty_ipsum_1.txt | wc -w >> kitty_info.txt
	-> | <- The pipe method 
	-> -w <- A flag 
-> echo -e "\nNumber of characters:" >> kitty_info.txt
	-> This is the same but with the number of characters 
	-> >> <- Append 
-> wc -m < kitty_ipsum_1.txt >> kitty_info.txt
	-> < <- Redirection method 
	-> wc -m < kitty_ipsum_1.txt <- Count the number of characters in this file, by using it as the input to this method 
	-> >> kitty_info.txt <- Take the output of that entire thing, and append it to this file 
-> grep 'meow' kitty_ipsum_1.txt
	-> Searching for patterns in text 
	-> Search for this pattern in this file 
-> man grep <- Manual pages
-> grep --color 'meow' kitty_ipsum_1.txt
	-> Print the entire file out and highlight the parts of it which we're searching for 
-> grep --color -n 'meow' kitty_ipsum_1.txt
	-> Do the same as the previous command, but in the output return the lines of each of the matches it finds 
-> grep --color -n 'meow[a-z]*' kitty_ipsum_1.txt
	-> meow[a-z]* <- To see all words in the file that start with meow 
-> echo -e "\nNumber of times meow or meowzer appears:" >> kitty_info.txt
	-> Append this statement to this txt file 
-> grep --color 'meow[a-z]*' kitty_ipsum_1.txt
	-> Search for the words which begin with this pattern in this txt file, and highlight them 
-> grep -c 'meow[a-z]*' kitty_ipsum_1.txt
	-> -c <- A flag for a count 
	-> Count the amount of times a word in this file begins with meow, and print out the value of that count in the terminal 
-> man grep <- Manual pages on this (the search) command 
-> grep -o 'meow[a-z]*' kitty_ipsum_1.txt
	-> -o <- A flag -> put the matches on their own lines 
	-> Find (grep, search for) all of the words in this text file which begin with meow and return those matching words on new lines 
-> grep -o 'meow[a-z]*' kitty_ipsum_1.txt | wc -l
	-> wc <- Count the lines 
	-> Before the pipe: grep -o 'meow[a-z]*' kitty_ipsum_1.txt
		-> The same as the previous line 
		-> It returns words in the text which match the search, and each word which matches the search is on its own line 
	-> We are taking the output of that line -> and piping it as the input of the command which counts the number of lines 
	-> So we are counting the number of words which match the search 
-> grep -o 'meow[a-z]*' kitty_ipsum_1.txt | wc -l >> kitty_info.txt
	-> Take the output of the previous command and append (>>) it to this txt file 
-> echo -e "\nLines that they appear on:" >> kitty_info.txt
	-> \n <- New line
	-> Add (>>) this echo statement to this txt file 
	-> -e <- To add back slash escapes 
-> grep -n 'meow[a-z]*' kitty_ipsum_1.txt
	-> -n <- To get line numbers
	-> Search for this pattern in this .txt file -> and for each match you find, print the match and the line number you found it on 
-> man grep <- Manual pages for the search command 
-> cat name.txt
	-> Print the content of this file 
	-> Use this file as the argument of that program 
-> sed 's/r/2/' name.txt
	-> sed 's/<pattern_to_replace>/<text_to_replace_it_with>/' <filename> 
	-> sed is to replace text 
	-> This outputs to stdout without a filename 
-> sed 's/free/f233/' name.txt
-> sed 's/freecodecamp/f233C0d3C@mp/' name.txt
	-> These are patterns 
-> sed 's/freecodecamp/f233C0d3C@mp/i' name.txt
	-> Adding regex flags to tell it to ignore the case 
	-> We are replacing text -> there are cases it won't work if it's not case sensitive 
-> sed 's/freecodecamp/f233C0d3C@mp/i' < name.txt 
	-> To redirect the input 
	-> Use the name.txt file and put the input from it into this replace command `sed 's/freecodecamp/f233C0d3C@mp/I'`
-> cat name.txt | sed 's/freecodecamp/f233C0d3C@mp/i'
	-> | <- Pipe method
	-> Take the output of this command (print out the contents of this txt file), and use it as the input to this find and replace command 
-> grep -n 'meow[a-z]*' kitty_ipsum_1.txt
	-> Add the line numbers 	
	-> -n Flag 
	-> Search for this text in this file -> print the places you find it in the text, and the number line of that place 
-> grep -n 'meow[a-z]*' kitty_ipsum_1.txt | sed 's/[0-9]/1/'
	-> Replace 0-9 with 1 
	-> Before the pipe: grep -n 'meow[a-z]*' kitty_ipsum_1.txt
		-> Search for this text in this file 
		-> Print out the text in the file, but with the matching searches in bold 
		-> Also print out the line number you found the search item on 
	-> After the pipe: sed 's/[0-9]/1/'
		-> We have a block of text, with with the matching searches in bold and a (line) number to the left of the block of text each time a matching search result was found 
		-> Take that result, and use it as the input to this command -> which replaces all of the 0-9's with a 1 
-> grep -n 'meow[a-z]*' kitty_ipsum_1.txt | sed 's/[0-9]+/1/'
	-> This is the same as the previous line 
	-> This doesn't just find and replace the first digit 
-> man sed <- Search the manual pages for the find and replace command 
-> grep -n 'meow[a-z]*' kitty_ipsum_1.txt | sed -E 's/[0-9]+/1/'
	-> -n <- Flag 
	-> -E <- For extended regular expressions 
-> grep -n 'meow[a-z]*' kitty_ipsum_1.txt | sed -E 's/([0-9]+)/\1/'
	-> Capturing the numbers to use them in a replacement area
	-> We are finding and replacing with the sed command 
	-> We are using regex flags with this command for this 
-> grep -n 'meow[a-z]*' kitty_ipsum_1.txt | sed -E 's/([0-9]+).*/\1/'
	-> Matching everything else on each line and replacing it with a number
	-> We are capturing numbers and replacing everything with the captured numbers 
	-> Before the pipe: "grep -n 'meow[a-z]*' kitty_ipsum_1.txt"
		-> Search for all of the words which begin with meow in this text file 
	-> After the pipe: "sed -E 's/([0-9]+).*/\1/'"
		-> Replace it with this 
-> grep -n 'meow[a-z]*' kitty_ipsum_1.txt | sed -E 's/([0-9]+).*/\1/' >> kitty_info.txt
	-> Append (>>) the output of the previous command to this txt file 
-> grep --color 'cat[a-z]*' kitty_ipsum_1.txt
	-> Search (grep) for this pattern 
	-> Search this txt file for words which begin with cat
	-> Return that txt file in the terminal, but with all of the matching searches in red in that file 
-> echo -e "\nNumber of times cat, cats, or catnip appears:" >> kitty_info.txt
	-> Add this text to this txt file 
-> grep -o 'cat[a-z]*' kitty_ipsum_1.txt
	-> -o <- This is a flag 
	-> To find the number of terms which match the search 
	-> Search (grep) for words which begin with cat in this txt file 
	-> Then put all of the words you find that match it on their own line 
	-> Then the next command pipes this as the input into a command which counts the number of lines (the number of matching terms in the file / grep search)
		-> We are doing this across several different Bash lines 
-> grep -o 'cat[a-z]*' kitty_ipsum_1.txt | wc -l
	-> Before the pipe: the same as the previous line 
	-> Use that as the input for the command which counts the number of lines 
	-> wc <- Word count 
	-> -l <- Lines 
-> grep -o 'cat[a-z]*' kitty_ipsum_1.txt | wc -l >> kitty_info.txt
	-> Append (>>) the output of the previous command to this txt file
-> echo -e "\nLines that they appear on:" >> kitty_info.txt
	-> Append this line to this txt file 
-> grep -n 'cat[a-z]*' kitty_ipsum_1.txt
	-> grep (search for) all of the words in this txt file which start with cat
	-> Print out the lines of the text which match the search, and in front of each line print out the number in the original text which it was 
-> grep -n 'cat[a-z]*' kitty_ipsum_1.txt | sed -E 's/([0-9]+).*/\1/' 
	-> -E <- Extended regular expression flag 
	-> sed <- Extract only the line numbers (just find this)
	-> Take the output of the previous line, and replace it with this 
	-> Use these regex flags so that its case sensitive, and others 
-> grep -n 'cat[a-z]*' kitty_ipsum_1.txt | sed -E 's/([0-9]+).*/\1/' >> kitty_info.txt
	-> Add (>>) the output of the previous command to this txt file 
-> echo -e "\n\n~~ kitty_ipsum_2.txt info ~~" >> kitty_info.txt
	-> Add this line to this txt file 
-> echo -e "\nNumber of lines:" >> kitty_info.txt
-> cat kitty_ipsum_2.txt | wc -l >> kitty_info.txt
	-> wc - l <- Word count the number of lines (-l flag)
	-> cat kitty_ipsum_2.txt | wc -l <- Take the entire contents of this file, and pipe that as the input into the command which counts the number of lines in it
	-> >> kitty_info.txt <- Now add the result of that to this txt file 
-> echo -e "\nNumber of words:" >> kitty_info.txt
	-> Add this line to this txt file 
	-> Then we are going to append this piece of information to the file 
-> wc -w < kitty_ipsum_2.txt >> kitty_info.txt
	-> The number of words 
	-> wc -w < kitty_ipsum_2.txt <- Take this txt file, and use it as an input to this commands which counts the number of words 
		-> This is redirection
	-> >> kitty_info.txt <- Then take the output of that entire txt command, and add (>>, append) it to this txt file 
-> echo -e "\nNumber of characters:" >> kitty_info.txt
	-> Add (>>) this statement to this txt file 
	-> -e <- This is a flag 
-> wc -m < kitty_ipsum_2.txt >> kitty_info.txt
	-> >> kitty_info.txt <- Add it to this txt file 
	-> wc -m < kitty_ipsum_2.txt <- Perform the wc -m program using this txt file as an input to it 
-> grep --color 'meow[a-z]*' kitty_ipsum_2.txt
	-> We are using grep to search for patterns in the txt file 
	-> Searching for variations of meow, take the entire block of text which you searched and return what we were searching for highlighted red in bold 
-> echo -e "\nNumber of times meow or meowzer appears:" >> kitty_info.txt
	-> -e <- This is a flag 
	-> Add (>>) this statement to this txt file 
-> grep -o 'meow[a-z]*' kitty_ipsum_2.txt | wc -l >> kitty_info.txt
	-> grep -o 'meow[a-z]*' kitty_ipsum_2.txt | wc -l <- Extract the number 
	-> >> kitty_info.txt <- Append it to the txt file 
	-> -o <- This is a flag 
	-> Search (grep) for this pattern in this txt file, count the number of lines which this comes out with and add that number to this file 
-> echo -e "\nLines that they appear on:" >> kitty_info.txt
	-> Add (>>, append) this line to this txt file 
-> grep -n 'meow[a-z]*' kitty_ipsum_2.txt | sed -E 's/([0-9]+).*/\1/' >> kitty_info.txt
	-> Add line numbers 
	-> -n < This is a flag for the line numbers 
	-> -E <- This is a flag to allow regular extended expressions 
	-> Search for all of the words which begin with meow in this txt file, and put them on their own lines
	-> Then count the number of lines, perform a search and replace and add (>>, append) the output of that to this txt file 
-> grep --color 'cat[a-z]*' kitty_ipsum_2.txt
	-> Variations 
	-> --color <- This is a flag 
	-> Search for all of the words which begin with cat in this txt file 
	-> Print the txt file out in the terminal, with all of the terms which match what you want me to search for bold and red 
-> echo -e "\nNumber of times cat, cats, or catnip appears:" >> kitty_info.txt
	-> Add this line to this txt file 
	-> \n <- New line in front of the text 
-> grep -o 'cat[a-z]*' kitty_ipsum_2.txt | wc -l >> kitty_info.txt
	-> -o <- This is a flag
	-> Counting the number of lines 
	-> Search (grep) for words which start with this in this txt file, then count the number of lines they take up
	-> Add that number to the end of this txt file 
-> echo -e "\nLines that they appear on:" >> kitty_info.txt
	-> Add (>>, append) this text to the end of this txt file 
-> grep -n 'cat[a-z]*' kitty_ipsum_2.txt | sed -E 's/([0-9]+).*/\1/' >> kitty_info.txt
	-> Search for words which begin with cat in this txt file 
	-> Perform this search and replace (sed), where we only return the line numbers
	-> Add that result to the end of this txt file 
-> touch translate.sh
	-> Create a new shell (Bash) file 
-> chmod +x translate.sh
	-> Add executable file permissions to that Bash file, so it can be run in the terminal 
-> ./translate.sh kitty_ipsum_1.txt
	-> Execute this Bash file, and pass in this other file as the argument to that program 
-> ./translate.sh < kitty_ipsum_1.txt
	-> This does the same as the previous line, but using standard input redirection
-> cat kitty_ipsum_1.txt | ./translate.sh
	-> Pipe the contents of this txt file as the input to this other .sh file 
-> ./translate.sh kitty_ipsum_1.txt
	-> Execute this Bash file, with this txt file as the input to the program 

-> ./translate.sh kitty_ipsum_1.txt | grep --color 'dogchow'
	-> Before the pipe: ./translate.sh kitty_ipsum_1.txt
		-> Take this txt file and pass it as an argument into this .sh file 
	-> After the pipe: grep --color 'dogchow'
		-> Take the output of running the program, and search (grep) for 'dogchow' in the text
		-> When you find something which matches that in the text, highlight it red 
-> ./translate.sh kitty_ipsum_1.txt | grep --color 'catnip'
	-> This is the same as the previous line, but with 'catnip' not 'dogchow'
-> ./translate.sh kitty_ipsum_1.txt | grep --color 'dog[a-z]*'
	-> This is the same as with the previous line, but we are searching for words starting with 'dog', rather than 'catnip'
-> These are all the line, but they just highlight different parts of the text:
	-> ./translate.sh kitty_ipsum_1.txt | grep --color 'cat[a-z]*'
		-> Text that starts with cat 
	-> ./translate.sh kitty_ipsum_1.txt | grep --color 'dog[a-z]*|woof[a-z]*'
		-> Text that starts with 'dog', or 'woof'
	-> ./translate.sh kitty_ipsum_1.txt | grep --color -E 'dog[a-z]*|woof[a-z]*'
		-> -E <- This is a flag that searches with extended regular expression syntax 
	-> ./translate.sh kitty_ipsum_1.txt | grep --color -E 'meow[a-z]*|cat[a-z]*'
		-> Text that starts with meow or cat followed by any lowercase letters 
-> ./translate.sh kitty_ipsum_1.txt > doggy_ipsum_1.txt
	-> Execute the shell file with this txt file as the argument to the program 
	-> Take the result of that, and put the output (>) in this other txt file 
-> cat doggy_ipsum_1.txt
	-> Now show me the entire contents of that txt file 
-> diff kitty_ipsum_1.txt doggy_ipsum_1.txt
	-> Compare the contents of these two txt files (show me their differences)
-> man diff
	-> Show me the manual pages for this command 
-> diff --color kitty_ipsum_1.txt doggy_ipsum_1.txt
	-> Do the same as the previous line, but colour code the differences 
-> ./translate.sh kitty_ipsum_2.txt > doggy_ipsum_2.txt
	-> ./translate.sh kitty_ipsum_2.txt <- Execute this shell file, and use this txt file as the input to the program 
	-> Redirect the output of that program (>) to this txt file 
-> cat doggy_ipsum_2.txt
	-> Print out the contents of this file 
-> diff --color kitty_ipsum_2.txt doggy_ipsum_2.txt
	-> Compare the differences between these two txt files and highlight them in colour